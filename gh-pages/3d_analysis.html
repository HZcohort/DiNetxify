

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three-dimensional disease network analysis &mdash; DiNetxify  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
      <script src="_static/doctools.js?v=888ff710"></script>
      <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Visualization" href="visual.html" />
    <link rel="prev" title="Data harmonization" href="data_harm.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            DiNetxify
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="data_prep.html">Input data preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_harm.html">Data harmonization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Three-dimensional disease network analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#one-step-analysis">One-step analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#after-one-step-analysis">After one-step analysis:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-by-step-analysis">Step-by-step analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#phewas-analysis">3.2.1 PheWAS Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#disease-pair-generation">3.2.2 Disease pair generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comorbidity-strength-estimation">3.2.3 Comorbidity strength estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binomial-test">3.2.4 Binomial test</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comorbidity-network-analysis">3.2.5 Comorbidity network analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#disease-trajectory-analysis">3.2.6 Disease trajectory analysis</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="visual.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="table.html">Result tables description</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="log.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">DiNetxify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Three-dimensional disease network analysis</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/3d_analysis.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="three-dimensional-disease-network-analysis">
<h1>Three-dimensional disease network analysis<a class="headerlink" href="#three-dimensional-disease-network-analysis" title="Permalink to this heading"></a></h1>
<p>Once the data is prepared and stored in a <code class="docutils literal notranslate"><span class="pre">DiseaseNetworkData</span></code> object, DiNetxify offers two approaches to perform the disease network analysis:</p>
<ol class="arabic simple">
<li><p><strong>One-step analysis:</strong> a comprehensive pipeline that automates the entire sequence of analyses (PheWAS → disease pair generation → comorbidity strength estimation → binomial test → comorbidity network analysis → disease trajectory analysis) with one function call. This is convenient and ensures all steps are performed in the correct order with default or specified parameters.</p></li>
<li><p><strong>Step-by-step analysis:</strong> individual functions for each analysis component, allowing you to run and inspect each step separately. This approach offers more control and flexibility (e.g., to tweak parameters at each step or to examine intermediate results), at the expense of writing a bit more code.</p></li>
</ol>
<p>Both approaches output their results as pandas DataFrames, which you can further analyze or export (to CSV/Excel, etc.) using pandas. The one-step pipeline minimizes redundant computations and code, but does not allow modifying certain internal parameters beyond what its arguments expose. The step-by-step approach is more verbose but lets you adjust and understand each phase of the analysis in detail. We’ll demonstrate both.</p>
<section id="one-step-analysis">
<h2>One-step analysis<a class="headerlink" href="#one-step-analysis" title="Permalink to this heading"></a></h2>
<p>With your <code class="docutils literal notranslate"><span class="pre">DiseaseNetworkData</span></code> ready (let’s call it <code class="docutils literal notranslate"><span class="pre">data</span></code>), you can perform the entire analysis in one go using the <code class="docutils literal notranslate"><span class="pre">disease_network_pipeline()</span></code> function. This function returns all major result DataFrames and can also save output files. The example below illustrates using <code class="docutils literal notranslate"><span class="pre">disease_network_pipeline()</span></code>; it is applicable to any of the three study designs (the function internally adapts to the design specified in <code class="docutils literal notranslate"><span class="pre">data</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reminder:</span>
<span class="c1"># When using multiprocessing, ensure that the code is enclosed within the following block.</span>
<span class="c1"># This prevents entering a never ending loop of new process creation.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DiNetxify</span><span class="w"> </span><span class="kn">import</span> <span class="n">disease_network_pipeline</span>  

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>  <span class="c1"># Required when using multiprocessing on Windows/Mac  </span>
    <span class="n">phewas_result</span><span class="p">,</span> <span class="n">com_strength_result</span><span class="p">,</span> <span class="n">com_network_result</span><span class="p">,</span> <span class="n">binomial_result</span><span class="p">,</span> <span class="n">trajectory_result</span> <span class="o">=</span> <span class="n">disease_network_pipeline</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">n_process</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">n_threshold_phewas</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">n_threshold_comorbidity</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> 
        <span class="n">comorbidity</span> <span class="n">analysis</span><span class="p">,</span>
        <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;/your/project/path/results/&quot;</span><span class="p">,</span>
        <span class="n">project_prefix</span><span class="o">=</span><span class="s2">&quot;disease_network&quot;</span><span class="p">,</span>
        <span class="n">keep_positive_associations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_intermediate_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">system_exl</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;symptoms&#39;</span><span class="p">,</span> <span class="s1">&#39;others&#39;</span><span class="p">,</span> <span class="s1">&#39;injuries &amp; poisonings&#39;</span><span class="p">],</span>
        <span class="n">pipeline_mode</span><span class="o">=</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;RPCN&quot;</span><span class="p">,</span>
        <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BMI&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">],</span>
        <span class="n">matching_var_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sex&#39;</span><span class="p">:</span> <span class="s1">&#39;exact&#39;</span><span class="p">},</span>
        <span class="n">matching_n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">min_interval_days</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">max_interval_days</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>
        <span class="n">enforce_temporal_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> 
</pre></div>
</div>
<blockquote>
<div><p><strong>Note:</strong> When using multiprocessing, multi-threading may not always close successfully, which can cause conflicts that significantly affect performance. We recommend disabling multi-threading with the following code (Linux):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span><span class="w"> </span><span class="nv">OPENBLAS_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">MKL_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">BLIS_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">OMP_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">NUMEXPR_NUM_THREADS</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>or the following code in Windows:</p>
<div class="highlight-powershell notranslate"><div class="highlight"><pre><span></span><span class="nb">set </span><span class="n">OPENBLAS_NUM_THREADS</span><span class="p">=</span><span class="n">1</span>
<span class="nb">set </span><span class="n">MKL_NUM_THREADS</span><span class="p">=</span><span class="n">1</span>
<span class="nb">set </span><span class="n">BLIS_NUM_THREADS</span><span class="p">=</span><span class="n">1</span>
<span class="nb">set </span><span class="n">OMP_NUM_THREADS</span><span class="p">=</span><span class="n">1</span>
<span class="nb">set </span><span class="n">NUMEXPR_NUM_THREADS</span><span class="p">=</span><span class="n">1</span>
</pre></div>
</div>
</div></blockquote>
<ul>
<li><p><strong>Parameters (key arguments in <code class="docutils literal notranslate"><span class="pre">disease_network_pipeline</span></code>):</strong></p>
<ul class="simple">
<li><p><strong>data</strong> – The <code class="docutils literal notranslate"><span class="pre">DiseaseNetworkData</span></code> object containing your loaded cohort data.</p></li>
<li><p><strong>n_process</strong> – Number of parallel processes for computation. Use <code class="docutils literal notranslate"><span class="pre">1</span></code> for single-threaded execution, or higher to speed up analysis with multiprocessing (especially beneficial for large datasets). <em>(No default; you must specify this.)</em></p></li>
<li><p><strong>n_threshold_phewas</strong> – Minimum number of exposed cases required for a disease (phecode) to be included in the PheWAS analysis. This filters out very rare outcomes. (This value is passed to the internal <code class="docutils literal notranslate"><span class="pre">phewas()</span></code> function.)</p></li>
<li><p><strong>n_threshold_comorbidity</strong> – Minimum number of exposed individuals in whom a given disease pair co-occurs (considering both temporal and non-temporal occurrences) to include that pair in the comorbidity strength analysis. (Passed to <code class="docutils literal notranslate"><span class="pre">comorbidity_strength()</span></code>.)</p></li>
<li><p><strong>output_dir</strong> – Directory path for saving output files. The pipeline will create result files here (e.g., CSVs of significant results, log files, etc.). Use an absolute path or a path relative to your working directory.</p></li>
<li><p><strong>project_prefix</strong> – A string prefix for naming output files. For example, if <code class="docutils literal notranslate"><span class="pre">project_prefix=&quot;disease_network&quot;</span></code>, output files might be named like <code class="docutils literal notranslate"><span class="pre">disease_network_phewas_results.csv</span></code>, etc.</p></li>
<li><p><strong>keep_positive_associations</strong> – If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the pipeline will filter results to retain only “positive” associations: diseases with hazard ratio (HR) &gt; 1 in the PheWAS and disease pairs with positive correlation in comorbidity analysis. <em>(Default: False – retains all significant associations regardless of direction.)</em></p></li>
<li><p><strong>save_intermediate_data</strong> – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, intermediate <code class="docutils literal notranslate"><span class="pre">DiseaseNetworkData</span></code> objects (specifically those created during disease pair generation) will be saved to disk. This can be useful for debugging or inspecting intermediate steps, but will consume additional disk space. <em>(Default: False)</em>.</p></li>
<li><p><strong>system_exl</strong> – A list of phecode disease <em>systems</em> to exclude from all analyses. If certain categories of diseases (systems) are not of interest or should be filtered out (e.g., ‘symptoms’ or ‘injuries &amp; poisonings’), list them here. If set to None or an empty list, no system is excluded. <em>(Default: None)</em>. Valid system names include: <em>circulatory system, congenital anomalies, dermatologic, digestive, endocrine/metabolic, genitourinary, hematopoietic, infectious diseases, injuries &amp; poisonings, mental disorders, musculoskeletal, neoplasms, neurological, pregnancy complications, respiratory, sense organs, symptoms, others</em>.</p></li>
<li><p><strong>pipeline_mode</strong> – Specifies the order of analyses. Two modes are available:</p>
<ul>
<li><p><strong>‘v1’</strong>: PheWAS → comorbidity strength → binomial test → <em>then parallel/complementary</em>: comorbidity network analysis and disease trajectory analysis. (In this mode, the binomial test is run on all eligible disease pairs without considering network results, so trajectory and network analyses can be done independently.)</p></li>
<li><p><strong>‘v2’</strong>: PheWAS → comorbidity strength → comorbidity network analysis → binomial test → disease trajectory analysis. (In this mode, only the disease pairs deemed significant in the network analysis are subjected to the binomial test and subsequently used for trajectory analysis. This means the trajectory analysis focuses on a subset defined by network results.)
<em>(Default: ‘v1’)</em>. Choose ‘v2’ if you want a more stringent approach where trajectory analysis is conditional on network significance; otherwise, ‘v1’ covers all pairs passing earlier filters.</p></li>
</ul>
</li>
<li><p><strong>method</strong> – The method used for comorbidity network and disease trajectory analyses. Options are:</p>
<ul>
<li><p><strong>‘RPCN’</strong> – <em>Regularized Partial Correlation Network</em>. This method uses a regularized logistic regression framework including all other diseases as covariates (with L1 penalty) to evaluate direct disease-disease associations, adjusting for covariates. <em>(This is the default and our recommended approach.)</em></p></li>
<li><p><strong>‘PCN_PCA’</strong> – <em>Partial Correlation Network with PCA</em>. Similar to RPCN but applies principal component analysis to reduce dimensionality of the “other diseases” covariates before computing the network. This can simplify the model when there are many diseases.</p></li>
<li><p><strong>‘CN’</strong> – <em>Correlation Network</em>. A simpler approach using standard logistic regression for each disease pair (plus covariates) without partialling out other diseases. Essentially assesses correlation of each pair independently.
<em>(Default: ‘RPCN’)</em>. The choice of method will affect how comorbidity networks and trajectories are inferred.</p></li>
</ul>
</li>
<li><p><strong>covariates</strong> – List of covariate names to adjust for in the PheWAS, network, and trajectory analyses (in addition to the required <em>sex</em> variable, which is always adjusted for). These should match the covariate names you provided in <code class="docutils literal notranslate"><span class="pre">phenotype_data()</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">['BMI',</span> <span class="pre">'age']</span></code> as shown above. <em>(Default: None, meaning adjust for sex only along with any default adjustments like matching factors in matched cohorts.)</em></p></li>
<li><p><strong>matching_var_dict</strong> – A dictionary specifying how controls are matched to cases for the trajectory analysis (which uses an incidence density sampling approach). Keys are variable names to match on, and values specify matching criteria: for categorical or binary variables use <code class="docutils literal notranslate"><span class="pre">'exact'</span></code>; for continuous variables, provide a numeric tolerance. <strong>Important:</strong> use <code class="docutils literal notranslate"><span class="pre">'sex'</span></code> (literally) to match on sex (even if your original column name was different) because the data object uses a standardized ‘sex’ field. Other covariates should be referred to by their original names. <em>(Default: {‘sex’: ‘exact’}, meaning match controls to cases by sex.)</em>.</p></li>
<li><p><strong>matching_n</strong> – Maximum number of matched controls to select for each case in the trajectory analysis. For example, <code class="docutils literal notranslate"><span class="pre">matching_n=2</span></code> tries to find up to 2 controls per case. <em>(Default: 2)</em>.</p></li>
<li><p><strong>min_interval_days</strong> – Minimum time interval in days required between two diagnoses to consider one occurring <em>before</em> the other for temporal (trajectory) analysis. If the time between D1 and D2 diagnoses in an individual is less than or equal to this threshold, the pair is treated as effectively simultaneous (and thus not counted as a temporal sequence). <em>(Default: 0 days)</em>. Setting a positive number here can exclude very closely timed diagnoses from being considered as one preceding the other.</p></li>
<li><p><strong>max_interval_days</strong> – Maximum time interval in days to consider for disease pairs. If the gap between two diagnoses is larger than this, that pair occurrence might be ignored for certain analyses. This applies to both temporal (ordered) and non-temporal pair considerations. <em>(Default: infinity, i.e., no maximum gap applied.)</em>.</p></li>
<li><p><strong>enforce_temporal_order</strong> – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the pipeline will enforce strict temporal ordering in the trajectory analyses and related significance testing: any individual who has a disease pair in the opposite order (D2 before D1) may be excluded from certain calculations, and the binomial test will only consider pairs where a clear ordering can be established. In practice, setting this to True means the binomial test will ignore individuals who have the diseases in both orders, and the trajectory analysis will also respect the specified <code class="docutils literal notranslate"><span class="pre">min_interval_days</span></code> and <code class="docutils literal notranslate"><span class="pre">max_interval_days</span></code> strictly. <em>(Default: False)</em>.</p></li>
<li><p><strong>correction</strong> – The multiple hypothesis testing correction method to apply to p-values (where applicable). This uses methods from <code class="docutils literal notranslate"><span class="pre">statsmodels.stats.multitest.multipletests</span></code>. Options include <code class="docutils literal notranslate"><span class="pre">'bonferroni'</span></code>, <code class="docutils literal notranslate"><span class="pre">'holm'</span></code>, <code class="docutils literal notranslate"><span class="pre">'fdr_bh'</span></code>, etc. <em>(Default: ‘bonferroni’)</em>.</p></li>
<li><p><strong>cutoff</strong> – Significance cutoff for adjusted p-values. <em>(Default: 0.05)</em>. Any results with adjusted p-value above this threshold will be considered non-significant and typically filtered out from the final results.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">disease_network_pipeline</span></code> will return a tuple of DataFrames: in order, these correspond to <strong>phewas_result</strong>, <strong>com_strength_result</strong> (comorbidity strength), <strong>com_network_result</strong> (comorbidity network), <strong>binomial_result</strong>, and <strong>trajectory_result</strong>. In addition to returning these, the function writes out certain results and logs to files in <code class="docutils literal notranslate"><span class="pre">output_dir</span></code> for your records. You can adjust which results to focus on based on your research question (for instance, the comorbidity network and trajectory analyses might produce quite a lot of output; you could choose pipeline_mode ‘v1’ to consider them separately).</p>
</li>
</ul>
<section id="after-one-step-analysis">
<h3>After one-step analysis:<a class="headerlink" href="#after-one-step-analysis" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">disease_network_pipeline</span></code> will return a tuple of DataFrames: in order, these correspond to <strong>phewas_result</strong>, <strong>com_strength_result</strong> (comorbidity strength), <strong>com_network_result</strong> (comorbidity network), <strong>binomial_result</strong>, and <strong>trajectory_result</strong>. In addition to returning these, the function writes out certain results and logs to files in <code class="docutils literal notranslate"><span class="pre">output_dir</span></code> for your records.</p>
</section>
</section>
<section id="step-by-step-analysis">
<h2>Step-by-step analysis<a class="headerlink" href="#step-by-step-analysis" title="Permalink to this heading"></a></h2>
<p>In many cases, you might want to run each part of the analysis separately — for example, to inspect intermediate outputs, adjust parameters for individual steps, or run alternative filtering between steps. <em><strong>DiNetxify</strong></em> allows this by exposing individual functions for each analysis stage. Below we illustrate a step-by-step approach performing the same overall analysis as the one-step pipeline above. We will reuse the <code class="docutils literal notranslate"><span class="pre">data</span></code> object already loaded.</p>
<section id="phewas-analysis">
<h3>3.2.1 PheWAS Analysis<a class="headerlink" href="#phewas-analysis" title="Permalink to this heading"></a></h3>
<p>To perform a PheWAS (Phenome-Wide Association Study) using <em><strong>DiNetxify</strong></em>, use the <code class="docutils literal notranslate"><span class="pre">dnt.phewas()</span></code> function. This function will identify which diseases (phecodes) are significantly associated with the exposure of interest. In a cohort or matched cohort design, it runs Cox proportional hazards models (stratified by matching in the latter) and reports hazard ratios (HR) and p-values for each disease comparing exposed vs unexposed. In an exposed-only design, since there is no comparison group, this function simply flags diseases that exceed a certain incidence threshold.</p>
<p>The example below demonstrates a PheWAS in a matched cohort study, adjusting for covariates and using parallel processing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reminder: if using n_process &gt; 1, wrap calls in if __name__ == &quot;__main__&quot;:</span>

<span class="n">phewas_result</span> <span class="o">=</span> <span class="n">dnt</span><span class="o">.</span><span class="n">phewas</span><span class="p">(</span>  
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>                                             <span class="c1"># our DiseaseNetworkData object  </span>
    <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BMI&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">],</span>                             <span class="c1"># adjust for BMI and age (and sex by default)  </span>
    <span class="n">proportion_threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>                             <span class="c1"># require at least 1% of exposed have the disease  </span>
    <span class="n">n_process</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>                                           <span class="c1"># use 2 processes for parallel model fitting  </span>
    <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span>                               <span class="c1"># multiple testing correction method  </span>
    <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>                                           <span class="c1"># significance threshold  </span>
    <span class="n">system_inc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                       <span class="c1"># (optional) include only certain systems  </span>
    <span class="n">system_exl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                       <span class="c1"># (optional) exclude certain systems  </span>
    <span class="n">phecode_inc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                      <span class="c1"># (optional) include only certain phecodes  </span>
    <span class="n">phecode_exl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                      <span class="c1"># (optional) exclude certain phecodes  </span>
    <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>                                         <span class="c1"># (optional) log file prefix  </span>
    <span class="n">lifelines_disable</span><span class="o">=</span><span class="kc">False</span>                                <span class="c1"># whether to disable lifelines (Cox model library)  </span>
<span class="p">)</span>  

</pre></div>
</div>
<p>In this call:</p>
<ul class="simple">
<li><p>We specified <code class="docutils literal notranslate"><span class="pre">proportion_threshold=0.01</span></code> which means a phecode must have at least 1% of exposed individuals as cases to be considered. (This is an alternative to using <code class="docutils literal notranslate"><span class="pre">n_threshold</span></code>; you generally use one or the other, not both.)</p></li>
<li><p>We left inclusion/exclusion lists as None, meaning we are analyzing all diseases.</p></li>
<li><p>We enabled bonferroni correction on p-values and set a cutoff of 0.05 for significance.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lifelines_disable=False</span></code> means we use the lifelines Cox model (which is slower but handles certain edge cases better); if set to True, a custom faster method might be used but potentially less robust.</p></li>
</ul>
<p>Running <code class="docutils literal notranslate"><span class="pre">dnt.phewas()</span></code> returns a DataFrame (<code class="docutils literal notranslate"><span class="pre">phewas_result</span></code>). In a cohort design, this DataFrame will include columns such as: phecode, disease name, number of cases in exposed and unexposed, hazard ratio (HR) and its confidence interval, p-value, and adjusted p-value (q-value). For a matched cohort, similar output with stratified Cox results. For an exposed-only design, the output will likely include counts and perhaps a placeholder measure, primarily to identify which diseases meet the incidence threshold.</p>
<p>By examining <code class="docutils literal notranslate"><span class="pre">phewas_result</span></code>, you can see which diseases are significantly associated with your exposure of interest. Typically, for downstream analysis, you might focus on diseases with HR &gt; 1 and q-value &lt; cutoff (if you want only positive associations), which is exactly what the <code class="docutils literal notranslate"><span class="pre">keep_positive_associations=True</span></code> setting in the pipeline would enforce.</p>
<p>After obtaining <code class="docutils literal notranslate"><span class="pre">phewas_result</span></code>, if you want to apply a different multiple testing correction or filter in a custom way, <em><strong>DiNetxify</strong></em> provides convenience functions. For example, you can use <code class="docutils literal notranslate"><span class="pre">dnt.phewas_multipletests()</span></code> to adjust p-values in <code class="docutils literal notranslate"><span class="pre">phewas_result</span></code> using a specified method (if you didn’t do it inside <code class="docutils literal notranslate"><span class="pre">phewas()</span></code> or want to try a different method):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example: applying a different correction (e.g., FDR) to the PheWAS results  </span>
<span class="n">phewas_result</span> <span class="o">=</span> <span class="n">dnt</span><span class="o">.</span><span class="n">phewas_multipletests</span><span class="p">(</span>  
    <span class="n">df</span><span class="o">=</span><span class="n">phewas_result</span><span class="p">,</span>  
    <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;fdr_bh&#39;</span><span class="p">,</span>   <span class="c1"># Benjamini-Hochberg FDR  </span>
    <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.05</span>  
<span class="p">)</span> 
</pre></div>
</div>
<p>This will add/update columns in <code class="docutils literal notranslate"><span class="pre">phewas_result</span></code> for adjusted p-values and significance flags according to the chosen method and cutoff. (The <code class="docutils literal notranslate"><span class="pre">df</span></code> parameter is just the DataFrame from <code class="docutils literal notranslate"><span class="pre">phewas()</span></code>, so you can call this on any similar results DataFrame)</p>
</section>
<section id="disease-pair-generation">
<h3>3.2.2 Disease pair generation<a class="headerlink" href="#disease-pair-generation" title="Permalink to this heading"></a></h3>
<p>After identifying which diseases are associated with the exposure (through PheWAS), the next step is to generate all possible disease pairs from that set of diseases for further analysis. In <em><strong>DiNetxify</strong></em>, this is done using the <code class="docutils literal notranslate"><span class="pre">DiseaseNetworkData.disease_pair()</span></code> method, which operates on the <code class="docutils literal notranslate"><span class="pre">data</span></code> object. It will produce all combinations of the significant diseases (or all diseases if you choose) for each individual, distinguishing between <em>temporal</em> pairs (D1 before D2) and <em>non-temporal</em> co-occurrence. You can then filter these pairs by applying criteria like minimum co-occurrence counts or correlation as done in the next step.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">disease_pair()</span></code> method requires the PheWAS result DataFrame to know which diseases to consider. It also allows specifying time interval constraints. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate disease pairs for further analysis  </span>
<span class="n">pair_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">disease_pair</span><span class="p">(</span>  
    <span class="n">phewas_result</span><span class="o">=</span><span class="n">phewas_result</span><span class="p">,</span>     <span class="c1"># DataFrame from PheWAS (to get the list of diseases)  </span>
    <span class="n">min_interval_days</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>             <span class="c1"># minimum days between diagnoses for D1-&gt;D2 (0 = no minimum)  </span>
    <span class="n">max_interval_days</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>  <span class="c1"># maximum days between diagnoses to consider (inf = no limit)  </span>
    <span class="n">force</span><span class="o">=</span><span class="kc">False</span>                      <span class="c1"># if data already has pair info, this prevents overwrite unless True  </span>
<span class="p">)</span> 
</pre></div>
</div>
<ul class="simple">
<li><p><strong>phewas_result</strong> – the DataFrame of PheWAS results. Typically you would filter this to only include diseases you want to carry forward (e.g., all with p &lt; 0.05 and HR &gt; 1 if focusing on positive associations). If you pass the full <code class="docutils literal notranslate"><span class="pre">phewas_result</span></code>, the method might by default filter internally to significant ones depending on implementation. Check the content of <code class="docutils literal notranslate"><span class="pre">phewas_result</span></code> and perhaps subset it if needed.</p></li>
<li><p><strong>min_interval_days</strong>, <strong>max_interval_days</strong> – these define the time window for considering temporal relationships. As defined earlier, here we’ve left them at 0 and infinity which means we include all occurrences and do not impose a maximum gap. If you wanted to only consider, say, disease pairs where events occur within 5 years of each other, you could set <code class="docutils literal notranslate"><span class="pre">max_interval_days=1825</span></code> (approximately 5*365).</p></li>
<li><p><strong>force</strong> – similar to earlier methods, if False it will not recompute pairs if they were already computed before for this data object (to avoid unnecessary re-processing). Use True to force regeneration.</p></li>
</ul>
<p>The result <code class="docutils literal notranslate"><span class="pre">pair_data</span></code> (if returned, or it might store internally and return None – consult the actual function’s behavior) would contain information about each disease pair found in each person’s data. Typically, however, you won’t directly use this raw list; instead, the subsequent function <code class="docutils literal notranslate"><span class="pre">comorbidity_strength()</span></code> will use the <code class="docutils literal notranslate"><span class="pre">data</span></code> object which now has the disease pair info to calculate metrics.</p>
<blockquote>
<div><p>Note: In the one-step pipeline, disease_pair generation is handled internally; here we are making it explicit</p>
</div></blockquote>
</section>
<section id="comorbidity-strength-estimation">
<h3>3.2.3 Comorbidity strength estimation<a class="headerlink" href="#comorbidity-strength-estimation" title="Permalink to this heading"></a></h3>
<p>The next step is to assess the <strong>comorbidity strength</strong> of each disease pair – essentially measuring how strongly the two diseases are associated with each other in a cross-sectional sense (regardless of time order). <em><strong>DiNetxify</strong></em>’s <code class="docutils literal notranslate"><span class="pre">comorbidity_strength()</span></code> function calculates statistics like <strong>relative risk (RR)</strong> and <strong>Phi coefficient (Φ)</strong> for each pair, and can perform filtering and significance testing.</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">data</span></code> object (which now has disease pairs from the previous step), we can run:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reminder: if using n_process &gt; 1, wrap calls in if __name__ == &quot;__main__&quot;:</span>
<span class="n">com_strength_result</span> <span class="o">=</span> <span class="n">dnt</span><span class="o">.</span><span class="n">comorbidity_strength</span><span class="p">(</span>  
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>  
    <span class="n">proportion_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>    <span class="c1"># Alternatively, could require a certain prevalence  </span>
    <span class="n">n_threshold</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>             <span class="c1"># Only consider pairs that co-occur in at least 100 exposed individuals (same as we used above)  </span>
    <span class="n">n_process</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                 <span class="c1"># Single process (this function is usually fast; can set &gt;1 if needed)  </span>
    <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>               <span class="c1"># Log file (optional)  </span>
    <span class="n">correction_phi</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span> <span class="c1"># Correction method for Phi coefficient p-values  </span>
    <span class="n">cutoff_phi</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>             <span class="c1"># Significance cutoff for Phi  </span>
    <span class="n">correction_RR</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span>  <span class="c1"># Correction method for RR p-values  </span>
    <span class="n">cutoff_RR</span><span class="o">=</span><span class="mf">0.05</span>               <span class="c1"># Significance cutoff for RR  </span>
<span class="p">)</span>  

</pre></div>
</div>
<p>Important points about <code class="docutils literal notranslate"><span class="pre">comorbidity_strength()</span></code>:</p>
<ul class="simple">
<li><p>It uses the disease pairs present in <code class="docutils literal notranslate"><span class="pre">data</span></code> (so ensure you called <code class="docutils literal notranslate"><span class="pre">disease_pair()</span></code> first).</p></li>
<li><p>It focuses typically on the <em>exposed group</em> for calculations (since the design is cohort-based; if an exposed-only design, then it’s just that group).</p></li>
<li><p><strong>n_threshold</strong> here serves to filter out infrequent pairs (at least 100 co-occurrences as we set). This is analogous to <code class="docutils literal notranslate"><span class="pre">n_threshold_comorbidity</span></code> in the pipeline.</p></li>
<li><p>It will compute metrics like:</p>
<ul>
<li><p><strong>RR (Relative Risk)</strong> of the two diseases co-occurring in the same person, compared to what would be expected if independent (often simplified as co-occurrence probability vs product of marginal probabilities).</p></li>
<li><p><strong>Φ (Phi correlation)</strong> which is basically the Pearson correlation for two binary variables (disease present/absent).</p></li>
<li><p>P-values for these metrics (likely via chi-square tests or similar) and then it applies corrections (bonferroni in our case) to give adjusted p-values.</p></li>
</ul>
</li>
<li><p>The output <code class="docutils literal notranslate"><span class="pre">com_strength_result</span></code> will be a DataFrame where each row is a disease pair, with columns such as: disease1, disease2, count of individuals with both (possibly separate counts in exposed/unexposed), RR, RR_p-value, RR_q-value, Phi, Phi_p-value, Phi_q-value, etc., plus maybe some identifiers.</p></li>
</ul>
<p>After obtaining <code class="docutils literal notranslate"><span class="pre">com_strength_result</span></code>, you might want to filter it to retain only those pairs that meet certain criteria. The typical default (reflected in pipeline when <code class="docutils literal notranslate"><span class="pre">keep_positive_associations=True</span></code>) is to keep only pairs with RR &gt; 1, Phi &gt; 0, and significance. However, you can examine this DataFrame and decide. A convenience function <code class="docutils literal notranslate"><span class="pre">comorbidity_strength_multipletests()</span></code> exists if you need to re-adjust p-values with a different method.</p>
</section>
<section id="binomial-test">
<h3>3.2.4 Binomial test<a class="headerlink" href="#binomial-test" title="Permalink to this heading"></a></h3>
<p>For each disease pair, if we want to determine if there is a <strong>preferred temporal order</strong> (i.e., does D1 tend to occur before D2 more often than vice versa), <em><strong>DiNetxify</strong></em> uses a binomial test. Essentially, for every individual who has both diseases, we check how many had D1 first vs D2 first, across all individuals. Under the null hypothesis of no preferred order, these are like coin flips; the binomial test checks if one order is significantly more common than the other.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">dnt.binomial_test()</span></code> performs this analysis. It uses the pair information in <code class="docutils literal notranslate"><span class="pre">data</span></code> (so again ensure <code class="docutils literal notranslate"><span class="pre">disease_pair()</span></code> was run). We can call it as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">binomial_result</span> <span class="o">=</span> <span class="n">dnt</span><span class="o">.</span><span class="n">binomial_test</span><span class="p">(</span>  
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>  
    <span class="n">enforce_temporal_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># If True, exclude individuals with ties/non-temporal occurrences  </span>
    <span class="n">min_interval_days</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>          <span class="c1"># (same as before)  </span>
    <span class="n">max_interval_days</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span>  
    <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span>      <span class="c1"># p-value correction method  </span>
    <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.05</span>                   <span class="c1"># significance threshold  </span>
<span class="p">)</span>  
</pre></div>
</div>
<ul class="simple">
<li><p><strong>enforce_temporal_order</strong> – If True, the function will exclude any “non-temporal” pairs (i.e., individuals where the two diseases occurred on the same day or essentially simultaneously, as defined by min_interval_days) from the counts. It also will ensure that if an individual has both orders of occurrence (e.g., D1 then D2 and later D2 then D1 due to multiple episodes), those might be handled to not bias the test. Since we set it False here, we’re being more permissive (which is fine given our min_interval_days=0, meaning simultaneous is allowed and counted in whichever order they happened first).</p></li>
<li><p><strong>min_interval_days, max_interval_days</strong> – These should match what was used in <code class="docutils literal notranslate"><span class="pre">disease_pair()</span></code> to ensure consistency in what “temporal” means.</p></li>
<li><p><strong>correction, cutoff</strong> – Correction for multiple tests (there’s one binomial test per disease pair) and significance threshold for the adjusted p-value.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">binomial_result</span></code> DataFrame will list disease pairs (likely identified by some code or name) with the number of individuals where D1 happened first vs D2 first, the binomial p-value and adjusted p-value, and possibly an indication of which order is predominant. Typically, one might filter this to pairs where p &lt; 0.05, indicating a significant temporal bias, and also note the direction (e.g., D1 -&gt; D2 is the more frequent sequence). This information will be used in building trajectories and in the next network analysis.</p>
</section>
<section id="comorbidity-network-analysis">
<h3>3.2.5 Comorbidity network analysis<a class="headerlink" href="#comorbidity-network-analysis" title="Permalink to this heading"></a></h3>
<p>Now we move to constructing the <strong>comorbidity network</strong> — a graph where nodes are diseases and edges represent associations between diseases, adjusting for covariates and other diseases per the method selected. This is effectively a deeper analysis on the set of disease pairs that survived earlier filters, focusing on direct relationships.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">dnt.comorbidity_network()</span></code> carries out this analysis. Depending on the <code class="docutils literal notranslate"><span class="pre">method</span></code> (RPCN, PCN_PCA, or CN), it will fit either a series of regularized regressions or simpler correlations. Here’s how we might call it (mirroring our pipeline parameters):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reminder: if using n_process &gt; 1, wrap calls in if __name__ == &quot;__main__&quot;:</span>

<span class="n">com_network_result</span> <span class="o">=</span> <span class="n">dnt</span><span class="o">.</span><span class="n">comorbidity_network</span><span class="p">(</span>  
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>  
    <span class="n">method</span><span class="o">=</span><span class="s2">&quot;RPCN&quot;</span><span class="p">,</span>           <span class="c1"># or &quot;PCN_PCA&quot; or &quot;CN&quot;  </span>
    <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BMI&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">],</span>        <span class="c1"># adjust for these covariates (plus sex) in each model  </span>
    <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span>          <span class="c1"># correction for multiple testing of edges  </span>
    <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>                      <span class="c1"># significance threshold  </span>
    <span class="o">**</span><span class="p">{</span>  
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>        <span class="c1"># RPCN-specific kwargs: if we wanted to manually set  </span>
        <span class="s2">&quot;auto_penalty&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="c1"># whether to auto-select alpha  </span>
        <span class="s2">&quot;alpha_range&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>  
        <span class="s2">&quot;scaling_factor&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>  
        <span class="c1"># If using PCN_PCA: we could provide &quot;n_PC&quot; or &quot;explained_variance&quot; as kwargs  </span>
    <span class="p">}</span>  
<span class="p">)</span>  

</pre></div>
</div>
<ul class="simple">
<li><p><strong>method</strong> – The network inference method: <code class="docutils literal notranslate"><span class="pre">'RPCN'</span></code> (default, uses L1-penalized partial correlation), <code class="docutils literal notranslate"><span class="pre">'PCN_PCA'</span></code> (partial correlation with dimensionality reduction), or <code class="docutils literal notranslate"><span class="pre">'CN'</span></code> (simple correlation network).</p></li>
<li><p><strong>covariates</strong> – Covariates to adjust for in the disease-disease association models. This should include ‘sex’ if you want to adjust for sex (note: in the code, sex is likely automatically included; but to be safe you could include it, though in some contexts they say “sex is always required, use ‘sex’”). We include BMI and age as in PheWAS.</p></li>
<li><p><strong>correction, cutoff</strong> – multiple testing correction for the edge significance and the significance threshold. Each edge (disease pair) will get a p-value (from logistic regression coefficients, etc.), and these will be corrected. We use Bonferroni and 0.05.</p></li>
<li><p><strong>kwargs</strong> – RPCN and PCN_PCA have additional hyperparameters:</p>
<ul>
<li><p>For RPCN: <code class="docutils literal notranslate"><span class="pre">alpha</span></code> (L1 penalty weight; if None or auto_penalty True, the code will try to auto-tune it), <code class="docutils literal notranslate"><span class="pre">auto_penalty</span></code> (if True, find optimal alpha via AIC), <code class="docutils literal notranslate"><span class="pre">alpha_range</span></code> (range to search for alpha), <code class="docutils literal notranslate"><span class="pre">scaling_factor</span></code> (scales alpha search). We left <code class="docutils literal notranslate"><span class="pre">alpha=None</span></code> and <code class="docutils literal notranslate"><span class="pre">auto_penalty=True</span></code> which means the software will choose the best penalty.</p></li>
<li><p>For PCN_PCA: <code class="docutils literal notranslate"><span class="pre">n_PC</span></code> (number of principal components to use; default 5) and/or <code class="docutils literal notranslate"><span class="pre">explained_variance</span></code> (if set, override n_PC to take enough PCs to explain this fraction of variance). Not used in RPCN.</p></li>
</ul>
</li>
<li><p>The output <code class="docutils literal notranslate"><span class="pre">com_network_result</span></code> will be a DataFrame capturing which disease pairs (edges) are considered significant in this network analysis. It likely includes columns like: disease1, disease2, coefficient (beta or correlation), p-value, adjusted p-value, etc., and an indicator of significance. Additionally, it might list communities if computed (though community detection is usually a separate visualization step).</p></li>
</ul>
<p>After this, you could filter <code class="docutils literal notranslate"><span class="pre">com_network_result</span></code> to only significant edges (adjusted p &lt; 0.05) if you want to focus on the final network structure. Non-significant edges might be dropped for interpretation.</p>
</section>
<section id="disease-trajectory-analysis">
<h3>3.2.6 Disease trajectory analysis<a class="headerlink" href="#disease-trajectory-analysis" title="Permalink to this heading"></a></h3>
<p>Finally, we conduct the <strong>disease trajectory analysis</strong>. This aims to identify sequences of diseases, i.e., if having disease D1 increases the risk of subsequently developing disease D2 (beyond just co-occurrence). This is typically done with a nested case-control approach or similar incidence density sampling that was set up by matching_var_dict and matching_n earlier. Essentially, for each candidate pair from the comorbidity analysis, we treat the first-occurring disease as an exposure and the second as an outcome in a survival analysis framework to test the temporal association (while accounting for matching and covariates).</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">dnt.disease_trajectory()</span></code> performs this analysis. We will call it on the filtered set of disease pairs. In pipeline mode ‘v2’, that set is restricted to those significant in the network; in ‘v1’, it’s basically all pairs from the comorbidity strength step (perhaps already filtered by RR/Phi positivity). You can decide which input to give it (e.g., you might filter <code class="docutils literal notranslate"><span class="pre">com_strength_result</span></code> or use <code class="docutils literal notranslate"><span class="pre">com_network_result</span></code>). Here, assuming we want to analyze trajectories for all pairs identified as having some comorbidity strength (since we didn’t filter by network first in our pipeline example):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reminder: if using n_process &gt; 1, wrap calls in if __name__ == &quot;__main__&quot;:</span>

<span class="n">trajectory_result</span> <span class="o">=</span> <span class="n">dnt</span><span class="o">.</span><span class="n">disease_trajectory</span><span class="p">(</span>  
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>  
    <span class="n">covariates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;BMI&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">],</span>         <span class="c1"># adjust for these covariates (and sex implicitly)  </span>
    <span class="n">matching_var_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sex&#39;</span><span class="p">:</span> <span class="s1">&#39;exact&#39;</span><span class="p">},</span> <span class="c1"># matching variables and criteria (as used earlier)  </span>
    <span class="n">matching_n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>                      <span class="c1"># number of matched controls per case  </span>
    <span class="n">enforce_time_interval</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>       <span class="c1"># whether to enforce min/max intervals in analysis  </span>
    <span class="n">correction</span><span class="o">=</span><span class="s1">&#39;bonferroni&#39;</span><span class="p">,</span>           <span class="c1"># p-value correction method  </span>
    <span class="n">cutoff</span><span class="o">=</span><span class="mf">0.05</span>                        <span class="c1"># significance threshold  </span>
<span class="p">)</span>  

</pre></div>
</div>
<ul class="simple">
<li><p><strong>covariates</strong> – Covariates to include in the models (again, include things like BMI, age; sex is always considered). These models are typically conditional logistic regressions or Cox models within matched sets, depending on how implemented.</p></li>
<li><p><strong>matching_var_dict</strong> and <strong>matching_n</strong> – These should match how we set them before generating the controls (the pipeline or earlier code ensures consistent matching was applied to identify controls; by providing the same parameters, we ensure it uses those controls). In our example, we matched on sex exactly and allowed up to 2 controls per case.</p></li>
<li><p><strong>enforce_time_interval</strong> – If True, the function would ensure that only disease pairs within the specified min/max intervals are considered in the modeling. Since we set it False, it will include all pairs (the min/max were already applied when generating pairs if at all).</p></li>
<li><p><strong>correction, cutoff</strong> – multiple testing correction for the trajectory analysis p-values and the significance threshold.</p></li>
</ul>
<p>The output <code class="docutils literal notranslate"><span class="pre">trajectory_result</span></code> will be a DataFrame of disease pairs with metrics indicating temporal association significance. Likely, for each pair (D1 -&gt; D2), it provides an estimated effect size (perhaps an odds ratio or hazard ratio for D1 leading to D2), confidence interval, p-value, and adjusted p-value, plus an indicator if it’s significant. Only pairs that passed previous filtering are analyzed, and among those, some will show a significant temporal relationship. In essence, this final result pinpoints which disease pairs have a directionality (D1 significantly predisposes to D2).</p>
<p>After completing these steps, you now have:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">phewas_result</span></code>: diseases associated with exposure</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">com_strength_result</span></code>: disease pairs with comorbidity strength metrics</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">binomial_result</span></code>: which pairs have a dominant order (not yet incorporating covariates, just raw order bias)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">com_network_result</span></code>: network edges that are significant controlling for others (direct relationships)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">trajectory_result</span></code>: disease pairs with significant temporal relationships (risk from one to the other)</p></li>
</ul>
<p>These correspond to the outputs of the one-step <code class="docutils literal notranslate"><span class="pre">disease_network_pipeline</span></code>. You can proceed to interpret them, and also to visualize them using the Plot class as described next.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="data_harm.html" class="btn btn-neutral float-left" title="Data harmonization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="visual.html" class="btn btn-neutral float-right" title="Visualization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>